---
## Author
author:
  name: Четвергова Мария Викторовна
  degrees: DSc
  orcid: 0000-0002-0877-7063
  email: kulyabov-ds@rudn.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Доклад на тему"
subtitle: "Функционирование защищённого протокола HTTPS"
license: "CC BY"
---

# Введение

Конечно, вот текст введения для доклада, соответствующий вашим требованиям.

---

### **Введение**

**Актуальность темы** 
Интернет стал неотъемлемой частью жизни: мы используем его для онлайн-банкинга, электронной коммерции, общения в социальных сетях и удаленной работы. Это приводит к колоссальному объему конфиденциальной информации, передаваемой по сети, — от персональных данных и переписки до финансовых реквизитов. Параллельно с ростом цифровых сервисов наблюдается стремительный **рост кибератак**, направленных на кражу этой информации. В таких условиях **защита приватности** становится не просто желательной опцией, а базовым требованием к любому онлайн-взаимодействию.

**Ключевая проблема**, лежавшая в основе интернета на заре его создания, — это уязвимость базового протокола передачи данных HTTP (HyperText Transfer Protocol). HTTP был разработан для простоты и скорости обмена информацией, но не для безопасности. Он передает все данные, включая логины и пароли, в открытом, незашифрованном виде. Это подобно отправке конфиденциального письма по почте на прозрачной открытке: любой, кто получит к нему доступ на пути от отправителя к получателю, может беспрепятственно прочитать и даже изменить его содержимое. Такая уязвимость создает прямую угрозу для пользователей, позволяя злоумышленникам осуществлять перехват трафика и атаки типа «человек посередине».

Для решения этой фундаментальной проблемы был разработан защищенный протокол HTTPS (HyperText Transfer Protocol Secure). 

**Целью данного доклада** является комплексное исследование принципов функционирования протокола HTTPS как основного механизма обеспечения безопасности данных в сети Интернет. 
Для достижения этой цели будут последовательно решены следующие задачи: 
* выявление недостатков протокола HTTP 
* раскрытие сущности и компонентов HTTPS
* изучение лежащих в его основе криптографических механизмов
* детальный разбор процесса установления безопасного соединения.

# Задачи доклада

1. Выявить недостатки протокола HTTP.
2. Раскрыть сущность и компоненты протокола HTTPS.
3. Изучить механизмы шифрования и аутентификации.
4. Подробно разобрать процесс установления безопасного соединения (TLS handshake).
5. Обозначить практическую значимость и преимущества HTTPS.

# 1. Необходимость защиты веб-трафика

Фундаментальной основой всемирной паутины долгое время являлся протокол HTTP. Однако его архитектурные особенности, изначально ориентированные на простоту и эффективность, со временем стали источником критических уязвимостей в условиях роста коммерческого и личного использования интернета. Понимание этих уязвимостей является ключевым для осознания той революционной роли, которую сыграло внедрение протокола HTTPS.

1.1. Протокол HTTP: принцип передачи данных в открытом виде
HTTP (HyperText Transfer Protocol) — это протокол прикладного уровня, определяющий правила взаимодействия между клиентом (например, веб-браузером) и сервером. Его основная задача — передача гипертекстовых документов (HTML-страниц). Главная характеристика HTTP, обусловившая его повсеместное распространение и одновременно главную слабость, — это отсутствие состояния (stateless) и, что наиболее важно, отсутствие встроенных механизмов шифрования.

Технически, HTTP-сессия представляет собой обмен текстовыми сообщениями. Когда пользователь вводит адрес сайта в браузере, тот отправляет на сервер текстовый запрос, например: GET /index.html HTTP/1.1. Сервер в ответ отправляет запрашиваемую страницу и сопутствующие ресурсы. Критически важно, что весь этот обмен происходит в открытом виде (plain text). Любые данные, включая имена пользователей, пароли, тексты личных сообщений или номера кредитных карт, передаются как обычный, читаемый текст.

Чтобы провести аналогию, передачу данных по HTTP можно сравнить с отправкой почтовой открытки. Содержание открытки видно любому, кто возьмет ее в руки на пути от отправителя к адресату — будь то почтальон, сортировщик или злоумышленник. Подобно тому, как мы не стали бы отправлять конфиденциальную информацию на открытке, передача важных данных через HTTP является крайне небезопасной. Эта «прозрачность» трафика создает благодатную почву для целого ряда кибератак.

1.2. Основные угрозы при использовании HTTP
Открытый характер передачи данных по протоколу HTTP порождает три основные класса угроз:

Перехват данных (Sniffing). Это пассивная атака, при которой злоумышленник, имеющий доступ к сетевому трафику на любом участке пути между клиентом и сервером (например, в публичной Wi-Fi-сети), прослушивает сетевой интерфейс и считывает все передаваемые данные. С помощью простых в использовании программ-снифферов (например, Wireshark) атакующий может в реальном времени увидеть логины, пароли, cookie-файлы сессий и другую конфиденциальную информацию. Поскольку данные не шифруются, для их прочтения не требуется взламывать сложные шифры — они уже представлены в готовом к использованию виде.

Подмена данных (Man-in-the-Middle — MitM, «Человек посередине»). Эта атака является более активной и опасной. Злоумышленник не только перехватывает трафик, но и активно его модифицирует, выступая в роли невидимого посредника между жертвой и целевым сервером. Например, когда пользователь пытается зайти на сайт банка, атакующий может перенаправить его на подконтрольный себе сервер, который внешне неотличим от настоящего. В этом случае пользователь, сам того не подозревая, вводит свои учетные данные прямо в руки злоумышленника. Более того, MitM-атака позволяет изменять содержимое веб-страниц на лету — например, подменить номер счета в реквизитах платежа или внедрить вредоносный код.

Фишинг и отсутствие аутентификации. Протокол HTTP сам по себе не предоставляет механизмов для проверки подлинности сервера. Пользователь не может быть уверен, что сайт, на который он зашел, является именно тем, за кого себя выдает. Этим активно пользуются фишеры, создавая поддельные сайты-двойники. Хотя фишинг существует и при HTTPS, отсутствие шифрования и зеленого значка замка в браузере делает поддельные сайты на HTTP менее заметными для неискушенного пользователя, упрощая социальную инженерию.

1.3. Историческая предпосылка появления HTTPS
Осознание уязвимостей HTTP пришло не сразу. На заре интернета, в 1990-е годы, Сеть использовалась в основном академическим сообществом для обмена научной информацией, и вопросы конфиденциальности не стояли так остро. Однако с началом коммерциализации интернета, появлением интернет-магазинов (таких как Amazon и eBay) и первых систем онлайн-банкинга в середине-конце 1990-х годов, необходимость в защите финансовых транзакций и личных данных стала очевидной и насущной.

Ответом на этот вызов стала компания Netscape Communications, разработчик одного из первых популярных веб-браузеров. В 1994 году Netscape разработала и внедрила в свой браузер протокол SSL (Secure Sockets Layer), целью которого было обеспечение безопасной связи. Протокол HTTPS появился как результат интеграции стандартного HTTP с этим криптографическим слоем SSL. Фактически, HTTPS — это не самостоятельный протокол, а использование HTTP поверх SSL (а впоследствии — его преемника, TLS).

Изначально HTTPS использовался исключительно для самых чувствительных операций, таких как страница входа в систему или оплаты. Шифрование было вычислительно сложной операцией, что создавало дополнительную нагрузку на серверы, поэтому его применение было точечным. Однако с ростом вычислительных мощностей, увеличением числа кибератак и всеобщим пониманием ценности приватности индустрия пришла к осознанию, что безопасность должна быть не опцией, а стандартом по умолчанию. Это привело к современному тренду на повсеместное внедрение HTTPS, который сегодня поддерживают и продвигают все крупнейшие IT-компании и поисковые системы.

Таким образом, переход от HTTP к HTTPS стал закономерным и необходимым эволюционным шагом, вызванным трансформацией интернета из инструмента для специалистов в глобальную инфраструктуру, от которой зависит экономика и частная жизнь миллиардов людей.



# 2. Основы протокола HTTPS

Протокол HTTPS представляет собой эволюционное развитие стандартного HTTP, направленное на устранение его ключевых уязвимостей. Его архитектура строится не на создании принципиально нового протокола, а на интегрировании проверенных криптографических механизмов, которые обеспечивают комплексную защиту данных на протяжении всего их пути от клиента к серверу и обратно.

2.1. Определение HTTPS:  HTTP поверх SSL/TLS

HTTPS (HyperText Transfer Protocol Secure) — это не самостоятельный протокол передачи данных, а расширение стандартного HTTP. Формально его можно представить как надстройку, где буква «S» означает «Secure» («Безопасный»). Эта безопасность достигается за счет инкапсуляции обычных HTTP-запросов и ответов в криптографический протокол SSL (Secure Sockets Layer) или его современного преемника TLS (Transport Layer Security).

Технически взаимодействие выглядит следующим образом:

Установка безопасного канала: Перед началом обмена HTTP-данными клиент и сервер с использованием протокола TLS устанавливают защищенное соединение. Этот процесс, известный как «рукопожатие» (handshake), включает в себя аутентификацию сервера и согласование параметров шифрования.

Передача данных: После успешного завершения «рукопожатия» весь последующий трафик (включая заголовки HTTP и тело сообщения) шифруется и передается по установленному безопасному каналу.

Таким образом, если HTTP работает непосредственно поверх транспортного протокола TCP (Transmission Control Protocol), то HTTPS располагается между HTTP и TCP, как бы «оборачивая» его. Схематично это можно изобразить так:

HTTP-стек: HTTP -> TCP -> IP

HTTPS-стек: HTTP -> TLS/SSL -> TCP -> IP

Именно слой TLS/SSL отвечает за выполнение трех критически важных функций безопасности: шифрование, обеспечение целостности и аутентификацию.

2.2. Три фундаментальные функции безопасности
В отличие от HTTP, HTTPS решает три ключевые задачи, превращающие «прозрачную открытку» в «запечатанный конверт».

Шифрование (Конфиденциальность)
Цель: Защитить передаваемые данные от несанкционированного прочтения. Даже в случае перехвата трафика злоумышленник увидит лишь бессмысленный набор символов.
Понятие шифра: Шифрование — это процесс преобразования исходного, читаемого текста (открытого текста, plaintext) в зашифрованный текст (шифротекст, ciphertext) с использованием специального алгоритма (шифра) и секретного ключа. Обратный процесс преобразования шифротекста обратно в открытый текст называется расшифровкой. Для этого требуется знание правильного ключа. В HTTPS используется гибридная система шифрования, сочетающая асимметричное и симметричное шифрование, что подробнее будет рассмотрено в следующей главе.

Целостность данных
Цель: Гарантировать, что данные не были изменены или повреждены в процессе передачи. Любая попытка подменить информацию будет немедленно обнаружена.
Механизм: Для обеспечения целостности в TLS применяются коды аутентификации сообщений (Message Authentication Code, MAC), в частности, HMAC (Hash-based Message Authentication Code). Принцип работы заключается в следующем: перед отправкой данных отправитель вычисляет для них уникальную криптографическую хэш-сумму (дайджест) с использованием общего секретного ключа. Эта хэш-сумма передается вместе с сообщением. Получатель, зная ключ, самостоятельно вычисляет хэш-сумму для принятых данных и сравнивает ее с полученной. Если даже один бит в сообщении был изменен, хэш-суммы не совпадут, и данные будут отклонены.

Аутентификация (Проверка подлинности сервера)
Цель: Убедиться, что клиент устанавливает соединение именно с тем сервером, с которым он намерен работать, а не с сайтом-подделкой, созданным злоумышленником.
Механизм: Аутентификация в HTTPS осуществляется с помощью цифровых сертификатов. Сертификат — это цифровой документ, который, подобно паспорту, удостоверяет личность владельца (доменное имя сервера). Этот сертификат выдается и подписывается доверенным сторонним лицом — Удостоверяющим центром (Certificate Authority, CA). Когда сервер представляет свой сертификат клиенту во время «рукопожатия», браузер проверяет:

Действительность цифровой подписи УЦ (проверяя ее по списку доверенных центров, встроенному в браузер).

Соответствие доменного имени в сертификате домену запрашиваемого сайта.

Срок действия сертификата.
Только успешное прохождение этих проверок гарантирует пользователю, что он общается с легитимным ресурсом.

2.3. Роль криптографических протоколов SSL и TLS. Эволюция и современное состояние
Исторически первым протоколом был SSL, созданный компанией Netscape в середине 1990-х годов. Со временем протокол развивался, и после версии SSL 3.0 его разработка была передана в руки Internet Engineering Task Force (IETF), которая стандартизировала его под новым названием TLS. Несмотря на смену названия, преемственность была сохранена: TLS 1.0 можно рассматривать как SSL 3.1.

Эволюция протокола была направлена на устранение обнаруженных уязвимостей и повышение производительности и безопасности:

SSL 2.0 и 3.0: Считаются устаревшими и небезопасными. Их использование настоятельно не рекомендуется.

TLS 1.0 и 1.1: Также были признаны уязвимыми (например, к атакам POODLE) и официально устарели в 2020 году.

TLS 1.2 (2008 г.): Долгое время являлся «золотым стандартом» безопасности. Он поддерживает современные и надежные криптографические алгоритмы, такие как шифрование AES в режиме GCM, который обеспечивает одновременно и конфиденциальность, и целостность данных. На сегодняшний день TLS 1.2 все еще широко распространен.

TLS 1.3 (2018 г.): Это современная и самая безопасная версия протокола. В ней были устранены многие уязвимости предыдущих версий, упрощена и ускорена процедура «рукопожатия» (в некоторых случаях до одного обмена пакетами), а также удалена поддержка устаревших и небезопасных алгоритмов шифрования. TLS 1.3 обеспечивает более сильное шифрование и повышенную производительность.

Важно отметить, что хотя сегодня повсеместно используется протокол TLS, термин «SSL» глубоко укоренился в лексиконе. Поэтому такие понятия, как «SSL-сертификат» или «SSL-шифрование», повсеместно используются как синонимы для «TLS-сертификата» и «TLS-шифрования», хотя технически это не совсем точно.

Таким образом, протокол HTTPS, базирующийся на современном TLS, представляет собой комплексное решение, которое превращает изначально небезопасный канал связи в защищенный, обеспечивая конфиденциальность, целостность и аутентификацию передаваемой информации.




# 3. Криптографические механизмы HTTPS


Безопасность протокола HTTPS обеспечивается строго определенным набором криптографических протоколов и инфраструктурой, стандартизированной организацией IETF (Internet Engineering Task Force). Данная глава описывает эти механизмы в соответствии с их официальными спецификациями.

**3.1. Цифровые сертификаты и инфраструктура открытых ключей (PKI)**

Основой для аутентификации сервера в HTTPS является инфраструктура открытых ключей (Public Key Infrastructure, PKI), которая определяется в стандарте ITU-T X.509.

**Что такое TLS-сертификат? Его структура и содержание.**
Цифровой сертификат X.509 — это электронный документ, который связывает открытый криптографический ключ с идентифицируемой информацией о владельце. Согласно RFC 5280, сертификат содержит следующие обязательные поля:
*   **Версия (Version):** Номер версии спецификации X.509.
*   **Серийный номер (Serial Number):** Уникальный идентификатор, присваиваемый сертификату Удостоверяющим центром (УЦ).
*   **Алгоритм цифровой подписи (Signature Algorithm):** Идентификатор алгоритма, используемого УЦ для подписи (например, sha256WithRSAEncryption).
*   **Издатель (Issuer):** Имя Удостоверяющего центра, выпустившего сертификат.
*   **Срок действия (Validity):** Период, в течение которого сертификат считается действительным (даты начала и окончания).
*   **Субъект (Subject):** Идентификация владельца сертификата, включая доменное имя в поле Common Name (CN) или, что предпочтительнее, в расширении Subject Alternative Name (SAN) согласно RFC 2818.
*   **Открытый ключ субъекта (Subject Public Key Info):** Открытый ключ и идентификатор используемого алгоритма (например, RSA с длиной 2048 бит).
*   **Цифровая подпись (Signature):** Подпись, вычисленная УЦ для всего вышеперечисленного содержимого сертификата.

**Удостоверяющие центры (Certificate Authorities, CA) и их роль**
Удостоверяющий центр — это организация, которая выпускает цифровые сертификаты. Роль УЦ как доверенной третьей стороны заключается в проверке того, что субъект, запрашивающий сертификат, контролирует указанное доменное имя. Процесс проверки регламентирован стандартом CA/Browser Forum. Браузеры и операционные системы поставляются с предустановленным набором корневых сертификатов доверенных УЦ (например, ISRG Root X1 для Let's Encrypt). Если сертификат веб-сайта подписан таким доверенным УЦ, браузер считает его действительным.

**Цепочка доверия.**
Цепочка доверия, как описано в RFC 5246 (TLS 1.2) и RFC 8446 (TLS 1.3), — это упорядоченный список сертификатов от корневого УЦ до сертификата сервера.
1.  **Корневой сертификат (Root CA Certificate):** Сертификат самоподписанного доверенного УЦ, предустановленный в хранилище браузера.
2.  **Промежуточный сертификат (Intermediate CA Certificate):** Сертификат, выпущенный корневым УЦ для делегирования полномочий по подписи. Это стандартная практика безопасности для изоляции корневого ключа, который хранится в режиме офлайн.
3.  **Сертификат конечного объекта (End-entity Certificate):** Сертификат, принадлежащий веб-серверу.
Браузер проверяет цепочку, убеждаясь, что цифровая подпись каждого сертификата в цепочке может быть проверена открытым ключом из следующего сертификата, вплоть до доверенного корневого.

 **3.2. Принципы шифрования**

HTTPS использует комбинацию алгоритмов шифрования, выбор которых согласуется во время TLS-рукопожатия.

**Асимметричное шифрование**
*   **Принцип работы:** Используются два разных, но математически связанных ключа: открытый (public key) и закрытый (private key). Открытый ключ используется для шифрования или проверки подписи, а закрытый — для расшифровки или создания подписи. Данные, зашифрованные открытым ключом, могут быть расшифрованы только парным закрытым ключом.
*   **Примеры алгоритмов:**
    *   **RSA (Rivest–Shamir–Adleman):** Шифрование и цифровые подписи. Безопасность основана на сложности факторизации больших целых чисел.
    *   **ECDSA (Elliptic Curve Digital Signature Algorithm):** Алгоритм цифровой подписи на основе эллиптических кривых, обеспечивающий сопоставимую с RSA безопасность при значительно меньшей длине ключа.
*   **Недостаток:** Как указано в RFC 8446, асимметричное шифрование требует значительных вычислительных ресурсов и неприменимо для прямого шифрования больших объемов данных.

**Симметричное шифрование**
*   **Принцип работы:** Для шифрования и расшифровки используется один и тот же секретный ключ, который должен быть известен обеим сторонам соединения.
*   **Примеры алгоритмов:**
    *   **AES (Advanced Encryption Standard):** Симметричный блочный шифр, утвержденный в качестве стандарта NIST (США). В TLS commonly используются режимы AES-GCM (Galois/Counter Mode) и AES-CCM, которые обеспечивают и конфиденциальность, и аутентификацию данных.
    *   **ChaCha20:** Потоковый шифр, часто используемый как альтернатива AES, особенно на мобильных устройствах.
*   **Преимущество:** Симметричное шифрование, такое как AES, значительно быстрее асимметричного.

**Гибридная схема в HTTPS**
Как определено в спецификациях TLS, используется гибридная схема для преодоления недостатков каждого типа шифрования:
1.  **Установление ключа с помощью асимметричного шифрования:** На этапе TLS-рукопожатия используется асимметричная криптография (например, RSA или алгоритм Диффи-Хеллмана на эллиптических кривых (ECDHE) из RFC 8422) для безопасного формирования общего **секрета главного ключа (master secret)**. Например, при использовании RSA клиент шифрует случайно сгенерированный pre-master secret открытым ключом сервера. Только сервер, обладающий закрытым ключом, может его расшифровать. В TLS 1.3 алгоритм Диффи-Хеллмана является обязательным, что обеспечивает forward secrecy.
2.  **Шифрование трафика с помощью симметричного шифрования:** На основе master secret обе стороны независимо вычисляют идентичные **ключи сессии** для симметричных алгоритмов (например, AES-256-GCM). Все последующие данные приложения (HTTP-запросы и ответы) шифруются и аутентифицируются с использованием этих ключей. Это обеспечивает высокую скорость передачи зашифрованных данных.

Эта гибридная модель, стандартизированная в протоколе TLS, позволяет безопасно обменить ключами, а затем использовать эффективное симметричное шифрование для основной сессии.

# 4.  Процесс установления безопасного соединения (TLS Handshake)


Конечно, вот текст четвёртой главы доклада, основанный на официальных спецификациях протоколов TLS.

---

### **Глава 4. Процесс установления безопасного соединения (TLS Handshake)**

Сердцем протокола HTTPS является процесс установления безопасного соединения, известный как TLS Handshake («рукопожатие»). Это сложный, но строго регламентированный набор шагов, в ходе которого клиент и сервер договариваются о параметрах безопасности, аутентифицируют друг друга и создают общие секретные ключи. Данное описание основано на механизме handshake в TLS 1.2 (описан в RFC 5246), который широко распространен и наглядно демонстрирует основные принципы. Ключевые отличия handshake в TLS 1.3 (RFC 8446) будут отмечены отдельно.

Процесс «рукопожатия» происходит до передачи любого HTTP-запроса и состоит из следующих этапов.

 **1. ClientHello**
Инициацию соединения всегда начинает клиент, отправляя сообщение `ClientHello`. Это сообщение содержит:
*   **Случайное число (Client Random):** 32-байтовая случайная последовательность, которая будет использоваться при генерации ключей.
*   **Список поддерживаемых версий TLS:** Например, TLS 1.0, TLS 1.2, TLS 1.3.
*   **Список поддерживаемых наборов шифров (Cipher Suites):** Набор шифров — это перечень алгоритмов, которые клиент готов использовать. Каждый набор определяет алгоритм для обмена ключами (например, RSA или ECDHE), алгоритм симметричного шифрования (например, AES_256_GCM) и алгоритм для вычисления кода аутентификации сообщений (MAC). Пример набора: `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`.
*   **Список поддерживаемых методов сжатия** (в современных реализациях обычно не используется).
*   **Прочие расширения (Extensions):** Например, список поддерживаемых эллиптических кривых или имя сервера (SNI - Server Name Indication), которое критически важно для хостинга с множеством сайтов на одном IP-адресе.

 **2. ServerHello**
Сервер отвечает сообщением `ServerHello`, в котором делает свой выбор из предложенных клиентом вариантов:
*   **Выбранная версия TLS:** Самая высокая версия, поддерживаемая обеими сторонами.
*   **Случайное число (Server Random):** Свое 32-байтовое случайное число, аналогичное клиентскому.
*   **Выбранный набор шифров (Cipher Suite):** Один конкретный набор шифров из списка, предоставленного клиентом.
*   **Идентификатор сессии (Session ID):** (Опционально, в TLS 1.3 удалено) Позволяет возобновить предыдущую сессию без полного handshake.

Далее сервер отправляет серию сообщений, которые обычно объединяются в одну запись (TCP-пакет):
*   **Сертификат (Certificate):** Сервер отправляет цепочку своих цифровых сертификатов X.509, начиная с сертификата сервера и включая все промежуточные сертификаты, необходимые для построения цепочки доверия до корневого УЦ.
*   **ServerKeyExchange:** (Требуется не всегда) Это сообщение необходимо, если выбранный набор шифров использует алгоритм Диффи-Хеллмана (например, ECDHE). В этом случае сервер отправляет свои параметры Диффи-Хеллмана (открытый ключ), подписанные своим закрытым ключом (для аутентификации).
*   **ServerHelloDone:** Сообщение, сигнализирующее клиенту о завершении передачи данных со стороны сервер

 **3. Проверка сертификата клиентом**
Клиент должен проверить подлинность сервера. Для этого он выполняет следующие действия с полученной цепочкой сертификатов:
1.  **Проверка цифровой подписи:** Клиент проверяет цифровую подпись каждого сертификата в цепочке, используя открытый ключ издателя (УЦ). Проверка идет последовательно, от сертификата сервера до корневого. Корневой сертификат считается доверенным, так как он предустановлен в хранилище доверенных центров клиента.
2.  **Проверка срока действия:** Клиент проверяет, что текущая дата и время находятся в промежутке между полями «Не ранее» (Not Before) и «Не после» (Not After) для каждого сертификата в цепочке.
3.  **Проверка доменного имени:** Клиент проверяет, что доменное имя, к которому он обращается, совпадает с именем, указанным в поле «Субъект» (Subject) или, что предпочтительнее, в расширении «Subject Alternative Name» (SAN) сертификата сервера.

Если любая из этих проверок завершается неудачей, браузер предупреждает пользователя о небезопасном соединении.

 **4. Генерация Pre-Master Secret и обмен ключами**
После успешной аутентификации сервера клиент генерирует ключевой материал для сессии. В зависимости от выбранного набора шифров процесс отличается:

*   **При использовании RSA (устаревший, не обеспечивает Forward Secrecy):**
    1.  Клиент генерирует 48-байтовое случайное число, называемое **Pre-Master Secret**.
    2.  Он шифрует это число с помощью **открытого ключа сервера**, полученного из его сертификата.
    3.  Зашифрованный Pre-Master Secret отправляется серверу в сообщении `ClientKeyExchange`.
*   **При использовании Ephemeral Diffie-Hellman (DHE/ECDHE, обеспечивает Forward Secrecy):**
    1.  Клиент генерирует свои собственные параметры (открытый ключ) Диффи-Хеллмана.
    2.  Он отправляет свой открытый ключ серверу в сообщении `ClientKeyExchange`.
    3.  И клиент, и сервер теперь имеют: свои собственные закрытые ключи и открытый ключ противоположной стороны. Каждая сторона **независимо** вычисляет одно и то же общее значение, которое становится **Pre-Master Secret**, используя алгоритм Диффи-Хеллмана.

TLS 1.3 полностью отказался от RSA для обмена ключами и использует только варианты Диффи-Хеллмана.

 **5. Вычисление общих ключей**
На этом этапе и клиент, и сервер имеют три общих компонента: **Client Random**, **Server Random** и **Pre-Master Secret**. Обе стороны независимо друг от друга используют одну и ту же функцию псевдослучайного генератора (PRF), определенную в стандарте, чтобы на основе этих трех значений вычислить:
1.  **Master Secret:** 48-байтовый главный секрет, который является основой для всех ключей.
2.  **Ключи сессии:** Из Master Secret, Client Random и Server Random генерируется несколько конкретных ключей:
    *   **Ключ симметричного шифрования для клиента** (для шифрования данных от сервера к клиенту).
    *   **Ключ симметричного шифрования для сервера** (для шифрования данных от клиента к серверу).
    *   **Ключи для кодов аутентификации сообщений (MAC)** для проверки целостности.

 **6. Finished-сообщения и завершение handshake**
Чтобы подтвердить, что handshake прошел успешно и ключи вычислены корректно, стороны обмениваются сообщениями `Finished`.
1.  Клиент отправляет сообщение `ChangeCipherSpec` (не является частью handshake-протокола, а является отдельным сообщением), которое уведомляет сервер о том, что все последующие сообщения будут зашифрованы новыми, только что вычисленными ключами.
2.  Затем клиент отправляет сообщение `Finished`. Это сообщение содержит хэш-сумму (HMAC) от всех предыдущих сообщений handshake, вычисленную с использованием только что созданного мастер-ключа. Это гарантирует, что ни одно из сообщений не было перехвачено или изменено.
3.  Сервер делает то же самое: отправляет `ChangeCipherSpec` и свое зашифрованное сообщение `Finished`.
4.  Клиент расшифровывает сообщение `Finished` от сервера и проверяет его корректность. Сервер аналогично проверяет сообщение клиента.

Если проверки `Finished` проходят успешно, TLS Handshake считается завершенным. С этого момента устанавливается защищенный симметричный канал связи, и начинается передача зашифрованных данных приложения, то есть HTTP-запросов и ответов.

**Схема процесса для TLS 1.2 (с использованием ECDHE) представлена в Приложении 1.**

**Краткое отличие TLS 1.3:** В TLS 1.3 handshake значительно оптимизирован и сокращен до одного обхода (1-RTT). Клиент сразу в `ClientHello` отправляет свои параметры Диффи-Хеллмана, а сервер в ответ отправляет `ServerHello` со своими параметрами, сертификат и `Finished` одновременно, что drastically сокращает задержку.



# Заключение

В ходе выполнения доклада были решены поставленные задачи. 

1. Выявлены и детально разобраны ключевые недостатки протокола HTTP, главным из которых является передача данных в открытом, незашифрованном виде, что создает угрозы перехвата и подмены информации. 

2. Раскрыта сущность HTTPS, которая заключается не в создании нового протокола, а в инкапсуляции HTTP в криптографический слой TLS. В-третьих, были изучены фундаментальные криптографические механизмы, лежащие в основе HTTPS: гибридная схема шифрования, сочетающая эффективность симметричных алгоритмов (AES) и безопасность асимметричных (RSA, ECDHE), а также инфраструктура открытых ключей (PKI) и цифровые сертификаты, обеспечивающие аутентификацию сторон. Наконец, был детально проанализирован процесс установления безопасного соединения (TLS handshake), наглядно демонстрирующий, как клиент и сервер договариваются о параметрах безопасности и вырабатывают общие секретные ключи.

Результаты работы убедительно доказывают, что HTTPS сегодня является не просто рекомендуемой опцией, а обязательным стандартом и базовым требованием для любого веб-ресурса. Это обусловлено не только необходимостью защиты конфиденциальности пользователей и финансовых транзакций, но и требованиями к доверию, продвижению в поисковых системах и корректной работе современных веб-технологий.

Перспективы развития протокола связаны с его постоянной эволюцией в сторону повышения безопасности и производительности. Ярким примером является версия TLS 1.3, которая устраняет уязвимые алгоритмы, упрощает и ускоряет handshake до одного обхода пакетов (1-RTT), а также делает обязательным использование алгоритмов с совершенной прямой секретностью (PFS), таких как Ephemeral Diffie-Hellman. В будущем можно ожидать дальнейшего ужесточения требований к сертификатам, более широкого внедрения квантово-устойчивых алгоритмов шифрования для защиты от будущих угроз и продолжения курса на максимальное упрощение и безопасность процесса установления доверенного соединения для пользователя.

Таким образом, HTTPS, основанный на надежных криптографических принципах и постоянно развивающийся, остается краеугольным камнем безопасности и конфиденциальности в глобальном информационном пространстве.


# Список литературы{.unnumbered}

1. Таненбаум Э., Уэзеролл Д. Компьютерные сети. 5-е изд. — СПб.: Питер, 2012. — 960 с. — Классический учебник, в котором на фундаментальном уровне разбираются принципы работы сетевых протоколов, включая основы криптографии и SSL/TLS (глава 8 "Безопасность в компьютерных сетях").

2. Кристофер Негус. Linux. Карманный справочник. — СПб.: Питер, 2020. — Практическая ценность: содержит руководство по использованию инструмента openssl для проверки сертификатов и диагностики SSL/TLS-соединений, что полезно для практического понимания
